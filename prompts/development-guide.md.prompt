# Public-Tunnel BDD Development Guide

## 快速開始

### 必讀文件
使用 Read tool 載入：
1. `CLAUDE.md` - 專案架構概覽
2. `docs/requirements/01_requirement.md` - 核心需求（繁體中文）
3. `docs/requirements/02_user_story.md` - 使用者故事
4. `docs/design/03_ooa_design.md` - 物件導向分析設計（實作藍圖）
5. `conftest.py` - BDD ScenarioContext 架構

### 開發流程

**Phase 1: 從 User Stories 建立測試結構**
1. 從 `docs/requirements/02_user_story.md` 選擇要實作的 user story
2. 在 `tests/features/` 下建立對應的 feature 檔案（如尚未存在）
3. 建立測試目錄結構和 step definitions 檔案
4. 所有 scenario 標記 `@skip`

範例結構：
```gherkin
Feature: Command Management
  As an AI Assistant
  I want to submit commands to clients
  So that I can control remote devices

  @skip
  Scenario: Submit command to registered client
    Given client "test-client" is registered and online
    When I submit command "ls -la" to client "test-client"
    Then the command should be queued successfully
    And I should receive a command ID
```

**Phase 2: 建立測試骨架**
1. 創建 `tests/features/{feature}/` 目錄結構
2. 創建 step definitions 檔案（given_*.py, when_*.py, then_*.py）
3. 所有 step definitions 使用 `NotImplementedError`
4. 確保 pytest 可以發現所有 scenarios

**Phase 3: TDD 實作**
1. 選擇一個 scenario，移除 `@skip`
2. RED: 測試失敗 (`pytest -m wip`)
3. GREEN Stage 1: 最小 FastAPI 端點（假資料）
4. GREEN Stage 2: 真實商業邏輯
5. REFACTOR: 程式碼品質改善

**Phase 4: 迭代循環**
1. 驗證目前 scenario 完成
2. 選擇下一個 scenario 或 feature
3. 重複 Phase 3

## 核心架構原則

### Session-Based 隔離
- 所有操作必須限制在 session 範圍內
- API 端點格式：`/api/sessions/{session_id}/...`
- 不同 session 間完全隔離

### HTTP Polling 通訊
- 只使用 HTTP，不使用 WebSocket
- Client 主動 polling 取得 commands
- FIFO 命令佇列

### FastAPI TestClient 整合
```python
# 在 step definitions 中
@when('I submit a command')
def submit_command(context):
    context.phase = BDDPhase.WHEN
    response = context.test_client.post("/api/sessions/default/commands", json={
        "command": "ls -la",
        "target_client": context.client_id
    })
    context.response = response
```

### BDD Phase 管理
```python
# GIVEN: 設定測試資料（自動在 GIVEN phase）
@given('client is registered')
def setup_client(context):
    context.client_id = "test-client"
    
# WHEN: 執行動作（明確設定 WHEN phase）
@when('I perform action')
def perform_action(context):
    context.phase = BDDPhase.WHEN
    context.response = context.test_client.get("/api/endpoint")

# THEN: 驗證結果（明確設定 THEN phase）
@then('I should see result')
def verify_result(context):
    context.phase = BDDPhase.THEN
    assert context.response.status_code == 200
```

## 常用指令

### pytest 指令
```bash
# TDD 開發循環
pytest -m wip -v

# 完整測試
pytest -v

# 測試發現
pytest tests/features/ --collect-only

# 特定功能
pytest tests/features/command_management/ -v
```

### FastAPI 指令
```bash
# 啟動開發伺服器
uvicorn public_tunnel.main:app --reload

# 安裝依賴
pip install -r requirements.txt
```

## 驗證檢查點

### API 設計檢查
- [ ] 所有端點包含 session_id
- [ ] HTTP status codes 正確
- [ ] Request/Response models 使用 Pydantic
- [ ] 錯誤處理一致

### Session 隔離檢查
- [ ] 不同 session 間資料完全隔離
- [ ] Command queuing 按 session 分離
- [ ] File operations 限制在 session 範圍

### BDD 邊界檢查
- [ ] Step definitions 只包含 API 呼叫
- [ ] 商業邏輯在應用程式碼中，不在測試中
- [ ] BDD phase 轉換正確
- [ ] Scenarios 獨立且可重複執行

## 常見問題解決

**Q: Step definitions 包含商業邏輯怎麼辦？**
A: 移動邏輯到 FastAPI 端點，step definitions 只做 API 呼叫和驗證

**Q: 測試失敗但不知道原因？**
A: 使用 `pytest -m wip -v -s --tb=long` 取得詳細資訊

**Q: Session 之間有資料洩漏？**
A: 檢查所有端點都包含 session_id，確保資料儲存按 session 分離

**Q: ScenarioContext phase 錯誤？**
A: 確保 WHEN 和 THEN steps 明確設定正確的 phase

## 快速參考

### 目錄結構
```
tests/features/
├── command_management.feature
├── command_management/
│   ├── __init__.py
│   ├── test_command_management.py
│   ├── given_*.py
│   ├── when_*.py
│   └── then_*.py
```

### API 端點模式
```python
# Session-scoped endpoints
POST /api/sessions/{session_id}/commands
GET  /api/sessions/{session_id}/clients
POST /api/sessions/{session_id}/files/upload

# Global endpoints (僅限必要時)
GET  /api/health
GET  /api/admin/sessions  # admin only
```

### Step Definition 模板
```python
from pytest_bdd import given, when, then, parsers
from conftest import BDDPhase

@given(parsers.parse('setup condition with "{param}"'))
def setup_condition(context, param):
    context.param = param
    # API setup call

@when(parsers.parse('I perform action with "{value}"'))
def perform_action(context, value):
    context.phase = BDDPhase.WHEN
    context.response = context.test_client.post("/api/endpoint", json={"value": value})

@then('I should see expected result')
def verify_result(context):
    context.phase = BDDPhase.THEN
    assert context.response.status_code == 200
```

## 成功標準

- 所有 user story scenarios 通過 BDD 測試
- FastAPI 端點遵循 session-based 架構
- HTTP polling 通訊正確實作
- Session 隔離完全運作
- 測試與業務邏輯適當分離
- 系統準備好與 AI assistant 整合

---

**使用方式**: 從 Phase 1 開始，按順序執行各階段。遇到問題時參考驗證檢查點和常見問題解決方案。